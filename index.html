<!DOCTYPE html>
<html>

<head>
    <title>Here be Pandas</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <style type="text/css">
        @import url('https://fonts.googleapis.com/css?family=Fira+Mono|Montserrat|Open+Sans');
        body {
            font-family: 'Open Sans';
            background: #49bc8d;
            background-color: #49bc8d;
        }

        .of {
            background: #49bc8d;
            color: #fafafa;
        }

        h1,
        h2,
        h3 {
            font-family: 'Montserrat';
            font-weight: light;
        }
        .remark-slide-content h1 { font-size: 2.6em; }
        .remark-slide-content h2 { font-size: 1.8em; }
        .remark-slide-content h3 { font-size: 1.6em; }
        .remark-code,
        .remark-inline-code {
            font-family: 'Fira Mono';
        }
        /* Two-column layout */

        .left-column {
            color: #777;
            width: 25%;
            height: 100%;
            float: left;
            border-right: #aaa solid 1px;
        }

        .left-column h2:last-of-type,
        .left-column h3:last-child {
            color: #000;
        }

        .right-column {
            width: 70%;
            float: right;
            padding-top: 0.5em;
        }

        .double-col {
            column-count: 3;
        }

        .double-col ul{
          font-family: 'Fira Mono';
            list-style-type: none;
        }
        .code{
          font-family: 'Fira Mono';
          background-color: #eee;
        }


        .footnote {
          position: absolute;
          bottom: 10em;
          left: 33%;
          right: 5em;
          font-style: italic;
          font-size: 0.8em;
          background-color: #eee;
          padding: 1em;
        }
        .link{
          color: #3a7ed7;
        }
    </style>
</head>

<body>
    <textarea id="source">

name: of
layout: true
class: center, middle, of
---
# Here be Pandas

*A high level introduction to Python and the pandas library*

<!-- ![]() -->
<!-- ![Mizaru]() .caption[*Mizaru* (see no evil)] -->
![:scale 50%](https://upload.wikimedia.org/wikipedia/commons/c/cd/Panda_Cub_from_Wolong,_Sichuan,_China.JPG)
---
layout: false
.left-column[
  ## Agenda
]
.right-column[
1. Introduction
2. What is Python
3. Python syntax
4. Pandas
5. Break
6. Project
]

---
layout: false
.left-column[
  ## Introduction
]
.right-column[
This work shop is intended to be a crash course in the Python programming language and how to use Pandas.

The goal of this workshop is that by the end of it you will comfortable enough to be able to fetch, manipulate, plot and output data.

Slides are available at: .link['https://nathanscully.github.io/herebepandas']

]

.footnote[pandas is an open source, BSD-licensed library providing high-performance, easy-to-use data structures and data analysis tools for the Python programming language.

.link[http://pandas.pydata.org/]]
---
layout: false
.left-column[
  ## What is Python?
]
.right-column[

![python](https://upload.wikimedia.org/wikipedia/commons/thumb/f/f8/Python_logo_and_wordmark.svg/260px-Python_logo_and_wordmark.svg.png)

Python is a interpreted language developed in the 90s and one of the mostly widely used programming languages in the world.

Designed for readbility with succinct expressions, it has an easy learning curve but alot of advanced powerful features. It is dynamically typed and supports multiple programming paradigms,  including object-oriented, imperative, functional programming, and procedural styles.

It is becoming the defacto standard for data processing and analysis but can be used for anything including backend web servers (Django).

There are currently 2 versions in the wild, 2 (.link[https://pythonclock.org/]) & 3.

]
---
layout: false
.left-column[
  ## The Python Manifesto
]
.right-column[

- Beautiful is better than ugly.
- Explicit is better than implicit.
- Simple is better than complex.
- Complex is better than complicated.
- Flat is better than nested.
- Sparse is better than dense.
- Readability counts.

]
.footnote[PEP 20 -- The Zen of Python]
---
layout: false
.left-column[
  ## Getting python
]
.right-column[
Version 2.7 comes by default on OSX. Don't use it.

You can install Python in 2 ways on OSX:
```
brew install python3
```

If you want to get straight into 'data science', you can use a opinoinated installer called .code[Anaconda] that will include ~ 100 basic libraries. [https://www.continuum.io/downloads
](https://www.continuum.io/downloads)

Running Python can be done via cmd line:

```
$ pything myapp.py
```
Or using notebooks, I recommend Jupyter: [http://jupyter.org/](http://jupyter.org/)
]
---
layout: false
.left-column[
  ## The look
]
.right-column[

Python is a whitespace indented language ðŸ˜± that is designed to be a highly readable.

  ```
  from app import World

  hello = World('hello')
  py = World('py')

  worlds = [hello, py]

  def count_worlds(worlds)
    return len(worlds)

  print("There are %s worlds" % count_worlds(worlds))
  >> There are 2 worlds

  hello.is_inhabitable
  >> True

  py.say_name()
  >> My name is `py`
  ```
]
---
layout: false
.left-column[
  ## Reserved words
]
.right-column[
It has a fairly short reserved word list:
.double-col[
* and
* as
* assert
* async
* await
* break
* class
* continue
* def
* del
* elif
* else
* except
* exec
* False
* finally
* for
* from
* global
* if
* import
* in
* is
* lambda
* None
* nonlocal
* not
* or
* pass
* print
* raise
* return
* True
* try
* while
* with
* yield
]]
---
layout: false
.left-column[
  ## FizzBuzz
]
.right-column[

Classic FizzBuzz example.

Note the indentations and use of .code[:] to delimit blocks.
  ```
  for num in range(1,101):
    if num % 5 == 0 and num % 3 == 0:
        print("FizzBuzz")
    elif num % 3 == 0:
        print("Fizz")
    elif num % 5 == 0:
        print("Buzz")
    else:
        print(num)
  ```
  ```
  >> 1
  >> 2
  >> Fizz
  >> 4
  >> Buzz
  >> Fizz
  >> 7
  >> 8
  >> Fizz
  >> Buzz
  >> 11
  ```
]
---
layout: false
.left-column[
  ## Syntax
]
.right-column[

We will cover the following:
- comments
- variables
- strings
- numbers
- collections
- dicts
- tuples
- classes
- functions
- lambda
- operators
- assertion
- logic
- iteration
]

---
layout: false
.left-column[
  ## comments
]
.right-column[

Python supports two different comment syntax, each has its own purpose.

Inline comments:
```
x = x + 1                 # Increment x

# multiline
# block
# comment
```

Docstrings, used in a function to to describe its purpose
```
def increment_by_1(x):
   """
   Increments x by 1
   """
   return x+1
```
]
---
layout: false
.left-column[
  ## variables
]
.right-column[

Python values, not variables, carry type. All variables in Python hold references to objects, and these references are passed to functions

Straight foward. PEP-8 suggests to use .code[lower_case_with_underscores] for variable names and .code[UPPER_CASE] for constants.

```
COMPANY = "Oneflare"
company_address = "120 Sussex St, Sydney"
```
]
---
layout: false
.left-column[
  ## strings
]
.right-column[

Either single or double quotes can be used to quote strings, they function the same.

You can use multiline strings by surrounding the block with .code["""].
You can also concatnate lines using .code[\], which is often helpful for readability.
```
COMPANY = 'Oneflare'

company_address = """
  Oneflare
  Level 7
  120 Sussex St, Sydney 2000
  Australia
  """

tagline = "The one connection you need" \
        'to get the job done'
>> The one connection you need to get the job done
```
]
---
layout: false
.left-column[
  ## numbers
]
.right-column[

Similar to other programming languages, the main number classes are .code[int] and .code[float].

```
one = 1  # int
one_point_0 = 1.0 # float

int(1.2351)
>> 1 # int

round(1.234516123241, 2)
>> 1.23 # float

int("2")
>> 2 # int
```
]
---
layout: false
.left-column[
  ## collections
]
.right-column[

The .code[list] class is a mutable sequence of objects. They are 0 indexed and you can splice them using the .code[[x:y]] syntax
```
staff = ['james', 'michelle', 'nathan']
staff.append('cookie')
>> ['james', 'michelle', 'nathan', 'cookie']

staff[1]
>> 'michelle'

staff[:2]
>> ['james', 'michelle']

staff[2:]
>> ['nathan', 'cookie']
```

The .code[set] class is a mutable sequence of objects that does not allow for duplicates. Note the .code[{...}]
```
staff = {'james', 'michelle', 'nathan', 'nathan', 'james'}
>> {'james', 'michelle', 'nathan'}
```
]
---
layout: false
.left-column[
  ## dicts
]
.right-column[

The .code[dict] class is a mutable mapping of key and values. Any type of value (function, object, Class etc can be mapped against a key) and they can be mixed.

Construnction is done via .code[{'key': value , ...}]
```
teams = {'james':'engineering',
         'michelle':'insights',
         'nathan':'insights',
         'cookie': ['insights', 'engineering', 1]}
```
Lookups can be done via .code[dict['key']]:
```
teams['james']
>>> 'engineering'
```

We can assign via .code[dict['key']=value]:
```
teams['cookie'] = 'c-suite'
```
]
---
layout: false
.left-column[
  ## tuples
]
.right-column[

The .code[tuple] class is an immutable sequence.

Construnction is normally done via  .code[(val1, val2, val3)] but the parentheses can be dropped (not recommended)
```
company_address = ('Level 7', '120 Sussex St', 'Sydney', 2000)
company_address = 'Level 7', '120 Sussex St', 'Sydney', 2000

```
You can access and expand the elements of a tuple using a list of named variables or via indexes.
```
level, street, suburb, postcode = company_address
>> level = 'Level 7'
>> street = '120 Sussex St'

postcode = company_address[3]
>> postcode = 2000
```

We can also use a namedtuple as a .code[Class] alternative.
```
from collections import namedtuple
Address = namedtuple('Address', 'level street suburb postcode')
adr = Address('Level 7', '120 Sussex St', 'Sydney', 2000)
adr.street
>> '120 Sussex St'
```
]
---
layout: false
.left-column[
  ## classes
]
.right-column[

As Python supports Object Orientated programming we can construct classes:
```
class MyClass:
    i = 12345
    def f(self):
        return 'hello Oneflare'

c = MyClass()
c.i
>> 12345
c.f()
>> 'hello Oneflare'
```
To initate an object with parameters we need to overload the .code[__init__] function:
```
class MyClass:
    def __init__(self, i=12345):
      self.i = i

c = MyClass()
c.i
>> 12345
c = MyClass(9876)
c.i
>> 9876
```
]
---
layout: false
.left-column[
  ## functions
]
.right-column[

In Python, functions are first-class objects that can be created and passed around dynamically.

```
def exponent(x, y):
    return x**y
exponent(2,3)
>> 8
```
Or:
```
def create_dag_sql_from_file_func(path):
    """
    Dynamically create a function based on a SQL file for
    Airflow to execute.
    """
    def func(ds, **kwargs):
        ph = PostgresHook(postgres_conn_id="OF_REDSHIFT")
        fd = open(path, 'r')
        sqlFile = fd.read()
        fd.close()
        ph.run(sqlFile)
    return func
```
]
---
layout: false
.left-column[
  ## lambdas
]
.right-column[

Python supports anonymous functions through the .code[lambda] keyword.
```
def exponent(x, y):
    return x**y
exponent(2,3)
>> 8

exponent = lambda x, y: x**y
exponent(2,3)
>> 8
```

These are *very* useful with Pandas.

]
---
layout: false
.left-column[
  ## operators
]
.right-column[

Python uses fairly standard operators: including: .code[+], .code[-], .code[*], .code[/], .code[%]
```
1 * 2
6 / 3
1 + 5
```

You can also increment/decrease using shorthand:

```
x = 1
x += 1
>> x = 2
x = 1
x -= 1
>> x = 1
```
]
---
layout: false
.left-column[
  ## assertion
]
.right-column[

Python can use operator based assertion using the following symbols: .code[==], .code[>=], .code[>], .code[<], .code[<=] and .code[!=]
```
1 != 2
2 == 2
3 < 4
4 > 1
```
It also supports keyword assertion using .code[and], .code[or], .code[not] and .code[in]
```
1 < 2 and 3 < 4
1 <2 or 2 > 1
1 in [1, 2, 3]
5 not in [1, 2, 3]
```
]
---
layout: false
.left-column[
  ## logic
]
.right-column[

Python uses .code[if], .code[elif] and .code[else] to support logic blocks.
```
if 1 in [1,2,3]:
  print("1 is in array")
elif 1 == 3:
  print("this won't work")
else:
  print("catch all")
```

You can use if statements to evaluate objections
```
x = None
if x:
  print("hello")
>>

if 1 < 3 and 2 < 3:
  return 5
```
]
---
layout: false
.left-column[
  ## iteration
]
.right-column[

Python has a number of ways of iterating:
```
for i in range(1,11):
  print(i)

for key, value in d.items():  # {'a':1, 'b':2}
  print(key, value)
>> a 1
>> b 2

count = 0
while (count < 9):
   print(count)
   count += 1
```

It also supports generators ðŸ˜€
```
evens = [i for i in range(1,11) if i % 2 == 0]
>> [2, 4, 6, 8, 10]

squared = { n: n**2 for n in range(5)}
>> {0: 0, 1: 1, 2: 4, 3: 9, 4: 16}
>> squared[3] = 9
```

]
---
class: center, middle, of

## Pandas

Or, how I learnt to love the data.
---
layout: false
.left-column[
  ## Pandas
]
.right-column[
*Pandas* is a library that provides Python with DataFrames and all the goodness that goes with them.

It describes itself as:

> The most powerful and flexible open source data analysis / manipulation tool available in any language.

It is the default onestop shop for reading and manipulating table based data and includes hooks for CSV, SQL I/O.

It also integrates nicely with Numpy, the standard numerical computation library for Python.

[http://pandas.pydata.org/](http://pandas.pydata.org/)
]
---
layout: false
.left-column[
  ## Dataframes
]
.right-column[
A Datafram is basically a table. Think of it as a mini database with columns and rows that you can query and perform functions on.

In a programming enviornment, think of it as an Excel sheet without the ability to click into the cells. You can write formulas in columns, you can pivot, you can group by.

You just need to know the write syntax!
]
---
layout: false
.left-column[
  ## Using Pandas
]
.right-column[
You need to import the library first:

```
import pandas as pd
```

You can now reference pandas in the applications namespace via 'pd'. e.g.:

```
import pandas as pd

df = pd.DataFrame(...)
```
]
---
layout: false
.left-column[
  ## Making a DataFrame
]
.right-column[

Creating a DataFrame can be done in a number of ways. You can provide the .code[pd.DataFrame(...)] constructor with a .code[list] of .code[lists], .code[tuples] or .code[dicts]

```
df = pd.DataFrame([[1,2,3],
                   [4,5,6],
                   [7,8,9]])
df
>>    0  1  2
>> 0  1  2  3
>> 1  4  5  6
>> 2  7  8  9


df = pd.DataFrame([(1,2,3),
                   (4,5,6),
                   (7,8,9)])
df
>>    0  1  2
>> 0  1  2  3
>> 1  4  5  6
>> 2  7  8  9
```
]
---
layout: false
.left-column[
  ## DataFrame with columns
]
.right-column[

By default, if you don't pass columns you will get numeric column values. You can use flat .code[dicts], which Pandas will use the keys of as column names, or you can manually specifiy columns.

```
# columns arg
df = pd.DataFrame([[1,2,3],
                   [4,5,6],
                   [7,8,9]],
                   columns=['A','B','C']))
df
>>    A  B  C
>> 0  1  2  3
>> 1  4  5  6
>> 2  7  8  9

# dicts
df = pd.DataFrame([{'A':1,'B':2,'C':3},
                   {'A':4,'B':5,'C':6},
                   {'A':7,'B':8,'C':9}])
df
>>    A  B  C
>> 0  1  2  3
>> 1  4  5  6
>> 2  7  8  9
```
]
---
layout: false
.left-column[
  ## Series
]
.right-column[

A series is a single, typed column or row in a DataFrame. Pandas makes a best guess on types when you load data in. Datetimes are handled fairly well if using a standard format, but the type can always be changed later.

You can access a series via index lookups on the DataFrame, and then convert all values to a list (in the order of the index) or individually via index lookups.

```
df
>>    A  B  C
>> 0  1  2  3
>> 1  4  5  6
>> 2  7  8  9

df['A']
>> 0    1
>> 1    4
>> 2    7
>> Name: A, dtype: int64

df['A'].values
>> [1 4 7]  # list

df['A'][0]
>> 1
```
]
---
layout: false
.left-column[
  ## Operations on Series
]
.right-column[

We can perform numeric calculations and .code[apply] lambda functuons on .code[series].

```
df
>>    A  B  C
>> 0  1  2  3
>> 1  4  5  6
>> 2  7  8  9

df['A'].sum()
>> 12

df['A'].count()
>> 3

df['A'].median()
>> 4.0

df['A'].apply(lambda ...)  # will be explained further
```
]
---
layout: false
.left-column[
  ## Selecting data
]
.right-column[

One of the most important things in analysing data is selecting the right data. DataFrames makes this easy with a consistent and easy syntax.

Pandas tends towards immutability, so most operations return new Series or DataFrames and are not applied to the original frame (unless specified/overwritten)

```
df
>>    A  B  C
>> 0  1  2  3
>> 1  4  5  6
>> 2  7  8  9

# Single column to get a series
df['A']
>> 0    1
>> 1    4
>> 2    7

# Multiple columns. This returns a NEW DataFrame
df[['A', 'C']]  #note double [[]]
>>    A  C
>> 0  1  3
>> 1  4  6
>> 2  7  9
```
]
---
layout: false
.left-column[
  ## Filtering data
]
.right-column[

One of the other most important parts of analysis is filtering data. There are 2 ways of doing this in Pandas, I recommend the first as I find it more flexible and consistent with the 'selection' syntax.

```
df
>>    A  B  C
>> 0  1  2  3
>> 1  4  5  6
>> 2  7  8  9

df[(df['A'] > 3)] # prefer this
>>    A  B  C
>> 1  4  5  6
>> 2  7  8  9

df.query('A > 3')
>>    A  B  C
>> 1  4  5  6
>> 2  7  8  9

```
]
---
layout: false
.left-column[
  ## Filtering data
]
.right-column[

Multiple filters can be applied by chaining boolean operations.

```
df
>>    A  B  C
>> 0  1  2  3
>> 1  4  5  6
>> 2  7  8  9

df.query('A > 3 and C < 7')
>>    A  B  C
>> 1  4  5  6

df[(df['A'] > 3) &
   (df['C'] < 7)]
>>    A  B  C
>> 1  4  5  6

```
]
---
layout: false
.left-column[
  ## Selecting a row
]
.right-column[

If you want access a single row in Pandas, there are couple of ways to do it. When you 'filter' data, the result is a DataFrame, not a 'row' (.code[series]) so you need to .code['squeeze'] the row to get it into a .code[series] (this only works if you have one row returned). If you use indexes, you can use the .code[loc] function.

```
df.loc[df['A']==1]
>>    A  B  C  row_multiple
>> 0  1  2  3            -1

type(df.loc[df['A']==1])
>> pandas.core.frame.DataFrame

df.loc[df['A']==1].squeeze()
>> A               1
>> B               2
>> C               3
>> row_multiple   -1
>> Name: 0, dtype: int64

df.loc[0] # uses the index column (defaults to row number)
>> A               1
>> B               2
>> C               3
>> row_multiple   -1
>> Name: 0, dtype: int64
```
]
---
layout: false
.left-column[
  ## Adding columns
]
.right-column[

We can add new columns by using the .code[.loc] function on a DataFrame. Data inserted can be aggregations of other columns of static values, or functions (next slide). This is done inplace.

```
df
>>    A  B  C
>> 0  1  2  3
>> 1  4  5  6
>> 2  7  8  9

df.loc[:, 'Totals'] = df['A'] + df['B'] + df['C']  # Prefered
>>    A  B  C  Totals
>> 0  1  2  3       6
>> 1  4  5  6      15
>> 2  7  8  9      24

df['Totals'] = df['A'] + df['B'] + df['C']  # avoid if you can
>>    A  B  C  Totals
>> 0  1  2  3       6
>> 1  4  5  6      15
>> 2  7  8  9      24

# See http://pandas.pydata.org/pandas-docs/stable/indexing.html#indexing-view-versus-copy
```
]
---
layout: false
.left-column[
  ## Adding columns with filters
]
.right-column[

We can use the filtering mechanism of .loc to only add values to certain rows.

```
df
>>    A  B  C
>> 0  1  2  3
>> 1  4  5  6
>> 2  7  8  9

df.loc[2:, "something"] = "hello"
>>    A  B  C something
>> 0  1  2  3       NaN
>> 1  4  5  6       NaN
>> 2  7  8  9     hello

df.loc[df['B']<6, "B less than 6"] = True
>>    A  B  C less than 6
>> 0  1  2  3        True
>> 1  4  5  6        True
>> 2  7  8  9         NaN
```
]
---
layout: false
.left-column[
  ##  The magic of apply
]
.right-column[

We can use lambda functions on series and rows to manipulate data in extended ways.

[](https://upload.wikimedia.org/wikipedia/commons/thumb/3/3a/Greek_lc_lamda_thin.svg/100px-Greek_lc_lamda_thin.svg.png)

> A lambda function is a function definition that is not bound to an identifier.

```
df
>>    A  B  C
>> 0  1  2  3
>> 1  4  5  6
>> 2  7  8  9

df.loc[:, 'A Squared'] = df['A'].apply(lambda a: a * a)
>>    A  B  C  A Squared
>> 0  1  2  3          1
>> 1  4  5  6         16
>> 2  7  8  9         49
```

![boom](http://i.giphy.com/10fdsa6b79iBDq.gif)
]
---
layout: false
.left-column[
  ##  Apply with defined functions
]
.right-column[

We can also pass values through defined functions when a lambda is to brief.

```
df
>>    A  B  C
>> 0  1  2  3
>> 1  4  5  6
>> 2  7  8  9

def random_multiply(i):
  x = random.randrange(10)
  y = i + x
  print("x: %s, y: %s" % (x, y))
  z = 'Result is %s' % y
  return z

df.loc[:, 'random_multiply'] = df['A'].apply(lambda i: random_multiply(i))
>> x: 4, y: 5
>> x: 7, y: 11
>> x: 2, y: 9
>>    A  B  C random_multiply
>> 0  1  2  3     Result is 5
>> 1  4  5  6    Result is 11
>> 2  7  8  9     Result is 9
```
]
---
layout: false
.left-column[
  ##  Apply at the row level
]
.right-column[

Whilst you can use .code[apply] at a series level, you can also use it a .code[row] level using .code[axis=1].
This passes a .code[pandas.core.series.Series] object into the function where the 'index' values are the row column names.
```
df
>>    A  B  C
>> 0  1  2  3
>> 1  4  5  6
>> 2  7  8  9

def row_multiple(row):
  return row['A'] * row['B'] - row['C']

df.loc[:, 'row_multiple'] = df.apply(lambda r: row_multiple(r), axis=1)
>>    A  B  C  row_multiple
>> 0  1  2  3            -1
>> 1  4  5  6            14
>> 2  7  8  9            47
```
]
---
layout: false
.left-column[
  ## Index
]
.right-column[

The Pandas index is a special 'hidden' column that can be used for selection and ordering. By default this is row number when data is loaded and is always attached to the row in a fairly immutable way. E.g. If you sort the DataFrame, the index will remain the same.
We can set the index on DataFrame using .code[index]. This makes the index column inaccesible by normal selection method but can be useful for joins and aggregations/groupbys.

```
df.sort_values(by='B', ascending=False)
>>    A  B  C
>> 2  7  8  9
>> 1  4  5  6
>> 0  1  2  3

df.set_index('B')
>>    A  C
>> B
>> 2  1  3
>> 5  4  6
>> 8  7  9
# now you can't df['B'] >> KeyError: 'B'
# but you can df.loc[5]
>> A    4
>> C    6
>> Name: 5, dtype: int64
```
]
---
layout: false
.left-column[
  ## Pivots
]
.right-column[

Fear not excel lovers, You can easily .code[pivot] a DataFrame

```
>>        Name  Age  Gender  Score
>> 0       Ken   35    Male    5.7
>> 1    Nathan   27    Male    8.2
>> 2  Michelle   16  Female    9.8
>> 3      Koen   28    Male    NaN

pd.pivot_table(people, index='Gender', aggfunc='sum')
>>          Age  Score
>> Gender
>> Female   16    9.8
>> Male     90   13.9

pd.pivot_table(people, index='Gender',
              values='score', aggfunc=('max','sum','min'))
>>         max   sum  min
>> Gender
>> Female  9.8   9.8  9.8
>> Male    8.2  13.9  5.7
```
]
---
layout: false
.left-column[
  ## Groupby
]
.right-column[

DataFrames can be grouped by Series names, both a single and a .code[list] of values is supported.
Note that the .code[.groupby()] returns a .code[pandas.core.groupby.DataFrameGroupBy] object, you need to make sure you give it an aggregation.
```
>>        Name  Age  Gender  Score
>> 0       Ken   35    Male    5.7
>> 1    Nathan   27    Male    8.2
>> 2  Michelle   16  Female    9.8
>> 3      Koen   28    Male    NaN

people.groupby('Gender').sum()
>>          Age  Score
>> Gender
>> Female   16    9.8
>> Male     90   13.9

people.groupby(['Gender','Age']).sum()
>>          Age  Score
>> Gender
>> Female   16    9.8
>> Male     90   13.9

people.groupby('Gender').aggregate({'Age':'median','Score':'mean'})
>>         Age  Score
>> Gender
>> Female   16   9.80
>> Male     28   6.95
```
]
---
layout: false
.left-column[
  ## Renaming columns
]
.right-column[

Often aggregates leave us with undesirable names. We can chain methods in Pandas to rename columns:
```
people.groupby('Gender').aggregate({'Age':'median','Score':'mean'})
                        .rename(columns={'Age':'Median Age', 'Score':'Mean Score'})
>>         Median Age  Mean Score
>> gender
>> Female          16        9.80
>> Male            28        6.95
```

Just remember that you need to assign the returned DataFrame for the operation to take affect. E.g.

```
df.rename(columns={'A':'thing'}) # nothing is persisted
df
>>        A  B  C
>> 0      1  2  3
>> 1      4  5  6
>> 2      7  8  9

df = df.rename(columns={'A':'thing'}) # correct
>>    thing  B  C
>> 0      1  2  3
>> 1      4  5  6
>> 2      7  8  9
```
]
---
layout: false
.left-column[
  ## Joining
]
.right-column[

We can merge DataFrames together using the .code[pd.merge] function:

```
people = pd.DataFrame([{'name':'Ken',         'age':35 ,  'gender': 'Male' },
                      {'name':'Nathan',     'age':27 ,  'gender': 'Male'  },
                      {'name':'Michelle',   'age':16 ,  'gender': 'Female' },
                      {'name':'Koen',       'age':28   , 'gender': 'Male'}])
scores = pd.DataFrame([{'name':'Ken',       'score':5.7 },
                      {'name':'Nathan',     'score':8.2 },
                      {'name':'Michelle',   'score':9.8 },
                      {'name':'Koen',       'score':None}])

pd.merge(people, scores, how='left')
>>    age  gender      name  score
>> 0   35    Male       Ken    5.7
>> 1   27    Male    Nathan    8.2
>> 2   16  Female  Michelle    9.8
>> 3   28    Male      Koen    NaN
```
We can also be explicit with the column names:
```
pd.merge(people, scores, how='left', left_on='name', right_on='name')

```

]
---
layout: false
.left-column[
  ## Iterating Rows
]
.right-column[

There may be times you wish to iterate over a Dataframe row by row. This is often useful to update mutiple columns at one time or if you wish to construct new objects for a row.

We do this using the .code[iterrows()] function on a DataFrame.

```
short_people =[]
for index, row in people.iterrows():
  gender_short = 'm' if row['gender'] == 'Male' else 'f'
  initials = ''.join([w[0] for w in row['name'].split(' ')])
  short_people.append((initials, gender_short))
short_people
>> [('KT', 'm'), ('NS', 'm'), ('MH', 'f'), ('KK', 'm')]
```

]
---
layout: false
.left-column[
  ## Chaining Functions
]
.right-column[

We can also chain functions in Pandas to be succinct (aka show off)
```
>>    age  gender            name  score
>> 0   35    Male      Ken Tabuki    5.7
>> 1   27    Male   Nathan Scully    8.2
>> 2   16  Female  Michelle Huang    9.8
>> 3   28    Male   Koen Kamphuis    NaN

(people.drop('name', axis=1)
             .join
             (
             people.name
             .str
             .split(expand=True)
             .stack()
             .reset_index(drop=True, level=1)
             .rename('name')
             ))

>>    age  gender  score      name
>> 0   35    Male    5.7       Ken
>> 0   35    Male    5.7    Tabuki
>> 1   27    Male    8.2    Nathan
>> 1   27    Male    8.2    Scully
>> 2   16  Female    9.8  Michelle
>> 2   16  Female    9.8     Huang
>> 3   28    Male    NaN      Koen
>> 3   28    Male    NaN  Kamphuis
```
]
---
layout: false
.left-column[
  ## Quantiles
]
.right-column[

Pandas a handy .code[quantile] function to allow us to return the quantile values for a .code[series]

See: [http://pandas.pydata.org/pandas-docs/stable/io.html](http://pandas.pydata.org/pandas-docs/stable/io.html)
```
>>    age  gender            name  score
>> 0   35    Male      Ken Tabuki    5.7
>> ...# hidden

people['age'].quantile()
>> 27.5   # defaults to 50%

np.arange(0,1.1,.1) # from the numpy library - very handy
>> array([ 0. ,  0.1,  0.2,  0.3,  0.4,  0.5,  0.6,  0.7,  0.8,  0.9,  1. ])

people['age'].quantile(np.arange(0,1.1,.1)) # float values for % quantiles
>> 0.0    16.0
>> 0.1    19.3
>> 0.2    22.6
>> 0.3    25.9
>> 0.4    27.2
>> 0.5    27.5
>> 0.6    27.8
>> 0.7    28.7
>> 0.8    30.8
>> 0.9    32.9
>> 1.0    35.0
```
]
---
layout: false
.left-column[
  ## Reading and Writing Data
]
.right-column[

Pandas has comprehensive I/O functions. The most common are to use .code[pd.read_csv] and .code[pd.read_sql] and .code[to_csv]

See: [http://pandas.pydata.org/pandas-docs/stable/io.html](http://pandas.pydata.org/pandas-docs/stable/io.html)
```
df = pd.read_csv('my_csv.csv')
df = pd.to_csv('new_csv.csv', index=False) # we don't want to add the
                                           # Index row numbers to the output
```

```
# python 3 from S3 via the boto client
import boto3
s3 = boto3.client('s3', ..credentials..)
obj = s3.get_object(Bucket='bucket', Key='key')
file = obj['Body'].read().decode('utf-8')
df = pd.read_csv(io.StringIO(file))
```

Using .code[read_sql] requires a library called SQLAlchemy and the various drivers. Example:
```
import sqlalchemy as sql
engine_string = "postgresql://%s:%s@%s:%s/%s" % (
    user, pw, host, port, db_name)
engine = sql.create_engine(engine_string)
df = pd.read_sql("SELECT * FROM mytable;", engine)
```
]
---
layout: false
.left-column[
  ## Plotting
]
.right-column[

Pandas has some plotting functions built in but its recommended to use .code[matplotlib] [http://matplotlib.org/](http://matplotlib.org/), or my personal prefernce .code[seaborn] [http://seaborn.pydata.org/](http://seaborn.pydata.org/)

For the examples I am going to use a sample dataset from Titanic passengers

```
import seaborn as sns
titanic = sns.load_dataset("titanic")
>> survived  pclass     sex   age  sibsp  parch     fare embarked  class
>> 0         0       3    male  22.0      1      0   7.2500        S  Third
>> 1         1       1  female  38.0      1      0  71.2833        C  First
>> 2         1       3  female  26.0      0      0   7.9250        S  Third
>> 3         1       1  female  35.0      1      0  53.1000        S  First
>> 4         0       3    male  35.0      0      0   8.0500        S  Third
```
]
---
layout: false
.left-column[
  ## Plotting (count)
]
.right-column[
We can do a simple count by a series.
```
sns.countplot(x="class", data=titanic)
sns.plt.show()
```
![](countplot.png)
]
---
layout: false
.left-column[
  ## Plotting (distribution)
]
.right-column[
We can look at the distribution of a series.
```
ages = titanic[titanic["age"].notnull()]['age'].values
sns.distplot(ages)
sns.plt.show()
```
![](distplot.png)
]
---
layout: false
.left-column[
  ## Plotting (scatter)
]
.right-column[
We can see the correlation between two values in a scatter plot
```
sns.regplot('age','fare',data=titanic, fit_reg=True)
sns.plt.show()
```
![](scatterplot.png)
]
---
layout: false
.left-column[
  ## Plotting (grids)
]
.right-column[
It is often helpful to compare series by another category:
```
import matplotlib.pyplot as plt
g = sns.FacetGrid(titanic, row="embark_town")
g = g.map(plt.scatter, 'age','fare')
sns.plt.show()
```
![](gridplot.png)
]
---
layout: false
.left-column[
  ## Plotting (scatter)
]
.right-column[
We can see the correlation between two values in a scatter plot
```
sns.regplot('age','fare',data=titanic, fit_reg=True)
sns.plt.show()
```
![](scatterplot.png)
]
---
layout: false
.left-column[
  ## Plotting (grids)
]
.right-column[
It is often helpful to compare series by another category:
```
import matplotlib.pyplot as plt
g = sns.FacetGrid(titanic, row="embark_town")
g = g.map(plt.scatter, 'age','fare')
sns.plt.show()
```
![](gridplot.png)
]
---
class: center, middle, of
## Lets get coding
*And have a quick break...*
---
layout: false
.left-column[
  ## Install python3 and juypter
]
.right-column[
Can you please all install python3 and use pip (python package manager) to install .[code jupyter pandas numpy seaborn]
```
brew install python3
# verify
python --version
>> Python 3.5.1
pip install jupyter pandas numpy seaborn
```
Make a new directory that we will run our notebook out of and launch jupyter
```
mkdir ~/Documents/Projects/herebepandas && cd  ~/Documents/Projects/herebepandas
jupyter notebook
```
]
---







    </textarea>
    <script src="js/remark.js" type="text/javascript">
    </script>
    <script type="text/javascript">
        remark.macros.scale = function(percentage) {
            var url = this;
            return '<img src="' + url + '" style="width: ' + percentage + '" />';
        };
        var slideshow = remark.create({
            'highlightStyle': 'tomorrow-night',
            'highlightLanguage': 'python',
            'ratio':'16:9'
        });
    </script>
</body>

</html>
